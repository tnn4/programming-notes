https://www.reddit.com/r/golang/comments/uepi26/comment/i6rhp80/?utm_source=share&utm_medium=web2x&context=3

comrade-quinn
Go is more explicit and verbose - but still feels lighter and leaner.

C# drains me when I go back to it. There’s too much abstraction and ‘magic’. I, like many, prefer explicit readable code, even if it is a little more verbose, compared to, perhaps, more concise, abstracted code.

Also, while not inherent in the languages, .NET as an ecosystem and culture tends to lean to over abstraction - with patterns like IOC and DI being the norm for almost any application and the default mechanism of decoupling in order to enable isolated testing of components.

Go is more aligned with the ‘Unix philosophy’ of single-purpose entities which are ‘composed’ to create solutions. This feels lighter, avoids needless complexity, and is more readable - while scaling just as well, or better - given scalability of code is, fundamentally, about readability.

Additionally, .NET has many ways to do the same thing and a litany of features that are minor variations on the same thing; for example classes, records, structs, ref types and value types - where Go has the typical standard types - all of which are value types. It also has pointer types that mean you can pass pointers around to any of the value types. And while you need to grock pointers, that’s no more difficult to understand than byref/val etc in .NET.

Similarly with concurrency, in .NET you have native threads, the threadpool, task parallel library and async/await. In Go you have standard functions, and a keyword (Go) that makes a function concurrent if you stick it before the invocation - that’s it.

Loops - in Go you have for… - that’s it. In .NET you have for, while, foreach, do, parallel.for, IEnumerable.ForEach and so on.

For fields, you have fields in Go. In .NET you have fields, inline properties, lambda properties, and full getter/setter properties.

I could go on, but I’m sure you get my point. To summarise; I love Go. I find .NET to be a giant hodge-podge of different ideas, approaches and patterns - while these sometimes add some sugar in isolation, they make the cognitive load of development greater overall

https://www.reddit.com/r/golang/comments/uepi26/comment/i6q8i7u/?utm_source=share&utm_medium=web2x&context=3
wretcheddawn
I currently program in both, and I do like both - these have been my two favorite languages for programming, and I feel both have been important gateways in my learning journey:

C# - There's a lot of syntactic sugar that while it can (and frequently is) abused, can reduce the verbosity in lots of operations. In particular, switch expressions, the ternary operator, pattern matching, null-checking, and lambda expressions. I like the built-in model binding for web APIs that handles a lot of boilerplate conversions and type checking for you. I like that many things can be marked up with Attributes that can be used to do all sorts of things, like specifying conversions, validation, etc. (go has this but only on struct members). Generics are very powerful.

On the bad side, C# apps are far less portable since you need the runtime, and ALL the dependent libraries for your app to work. I've been bitten by this while trying to make tools for QA or other team members who never have up-to-date runtimes installed, where with Go I can just give them a binary. In the ecosystem there are a lot of bad practices stemming from strict adherence to SOLID & "Pattern" programming that adds back more complexity than you saved with the language features, and eat up performance from constantly spraying new objects on the heap, virtual calls all over the place, and slow deferred execution of IEnumerable everything. Having to explicitly write async/await is just a waste of time. LINQ is neat, but leads to people not thinking about data structures at all, leading to a lot of badly performing code, and has some gotchas. When used for web programming, usually you're just coordinating data flow between slow things anyway, so performance ends up suffiently fast in the end to not be the bottleneck. Libraries and the framework are compiled and often closed-source, so it's harder to see what's going on under the hood, leading to "magic" functionality that can be tricky to understand and debug. C# has a lot of ways to hide complex functionality behind seemingly benign operations, which can make it really hard to reason about performance and also surprise you with bugs.

GO - I like the focus on simplicity and being closer to how things work at a lower level. Working on Go definitely helped me understand some concepts a lot better, particularly what "reference types" actually are, since "references" are explicit, how data structures and allocation affect performance, and the costs of different behaviors. I had to do different things to get readable code in Go, which I've been able to apply to other languages as well. Go's philosophies generally result in code that's easier to reason about and know what's happening, and also generally more performant. Ideas in the language are generally very elegant. Go libraries are open-source, so it's easy what something is doing and troubleshoot when things go wrong. Go's Web library doesn't support some of the syntactic niceties that you can do in .Net, but nonetheless complete. Go is generally very fast, though I suspect a lot of this is due to the terseness of the language where generally less LOC results in faster code. Go applications are very portable and I've even been able to reliably build linux binaries on windows. Async/await are automatic.

On the downside, Go can seems TOO simple. Code can get fairly verbose in places with a lot of errors and/or conditions. Some of the ways where Go does have a bit of syntactic sugar end up not being that useful, for example, I almost never find that the extra statement in an `if` block improves readability. Error handling is more straightforward than exceptions, but generally more verbose than many feel it should be. Some of the choices made for Go are _weird_, like that it's marketed as a systems language but it limits access to system apis & primitives, can't really be used to program a system, is garbage collected, has very few intrinsics, and the compiler doesn't optimize very well (no auto-vectorization), so can't be used for "true" high-performance software (at least, without writing hot loops in ASM). It's still much faster than anything but a "true" systems language like C/C++ but I have to judge the authors on the claims they made. The limited guidance on convention / structure can make it hard to know whether what you're doing is "good" or not, but TBH, I'd still rather work with badly-structured Go code over most other languages anyday. Generics are also a lot weaker than C#'s - not necessarily a bad thing as they're frequently abused in languages that do have them.

For my own projects, I've been choosing Go, mainly due to the lack of friction experienced while working in Go, but also because it's a personal goal of mine to learn more low level things. Go definitely taught me a lot, while it's not a "perfect" language IMO, it's one of the best, and I'd definitely recommend it to anyone looking to learn more.